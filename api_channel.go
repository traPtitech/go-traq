/*
traQ v3

traQ v3 API

API version: 3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package traq

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// ChannelApiService ChannelApi service
type ChannelApiService service

type ChannelApiCreateChannelRequest struct {
	ctx                context.Context
	ApiService         *ChannelApiService
	postChannelRequest *PostChannelRequest
}

func (r ChannelApiCreateChannelRequest) PostChannelRequest(postChannelRequest PostChannelRequest) ChannelApiCreateChannelRequest {
	r.postChannelRequest = &postChannelRequest
	return r
}

func (r ChannelApiCreateChannelRequest) Execute() (*Channel, *http.Response, error) {
	return r.ApiService.CreateChannelExecute(r)
}

/*
CreateChannel チャンネルを作成

チャンネルを作成します。
階層が6以上になるチャンネルは作成できません。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ChannelApiCreateChannelRequest
*/
func (a *ChannelApiService) CreateChannel(ctx context.Context) ChannelApiCreateChannelRequest {
	return ChannelApiCreateChannelRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Channel
func (a *ChannelApiService) CreateChannelExecute(r ChannelApiCreateChannelRequest) (*Channel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Channel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.CreateChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postChannelRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiEditChannelRequest struct {
	ctx                 context.Context
	ApiService          *ChannelApiService
	channelId           string
	patchChannelRequest *PatchChannelRequest
}

func (r ChannelApiEditChannelRequest) PatchChannelRequest(patchChannelRequest PatchChannelRequest) ChannelApiEditChannelRequest {
	r.patchChannelRequest = &patchChannelRequest
	return r
}

func (r ChannelApiEditChannelRequest) Execute() (*http.Response, error) {
	return r.ApiService.EditChannelExecute(r)
}

/*
EditChannel チャンネル情報を変更

指定したチャンネルの情報を変更します。
変更には権限が必要です。
ルートチャンネルに移動させる場合は、`parent`に`00000000-0000-0000-0000-000000000000`を指定してください。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId チャンネルUUID
	@return ChannelApiEditChannelRequest
*/
func (a *ChannelApiService) EditChannel(ctx context.Context, channelId string) ChannelApiEditChannelRequest {
	return ChannelApiEditChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *ChannelApiService) EditChannelExecute(r ChannelApiEditChannelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.EditChannel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchChannelRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChannelApiEditChannelSubscribersRequest struct {
	ctx                            context.Context
	ApiService                     *ChannelApiService
	channelId                      string
	patchChannelSubscribersRequest *PatchChannelSubscribersRequest
}

func (r ChannelApiEditChannelSubscribersRequest) PatchChannelSubscribersRequest(patchChannelSubscribersRequest PatchChannelSubscribersRequest) ChannelApiEditChannelSubscribersRequest {
	r.patchChannelSubscribersRequest = &patchChannelSubscribersRequest
	return r
}

func (r ChannelApiEditChannelSubscribersRequest) Execute() (*http.Response, error) {
	return r.ApiService.EditChannelSubscribersExecute(r)
}

/*
EditChannelSubscribers チャンネルの通知購読者を編集

指定したチャンネルの通知購読者を編集します。
リクエストに含めなかったユーザーの通知購読状態は変更しません。
また、存在しないユーザーを指定した場合は無視されます。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId チャンネルUUID
	@return ChannelApiEditChannelSubscribersRequest
*/
func (a *ChannelApiService) EditChannelSubscribers(ctx context.Context, channelId string) ChannelApiEditChannelSubscribersRequest {
	return ChannelApiEditChannelSubscribersRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *ChannelApiService) EditChannelSubscribersExecute(r ChannelApiEditChannelSubscribersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.EditChannelSubscribers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}/subscribers"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchChannelSubscribersRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChannelApiEditChannelTopicRequest struct {
	ctx                    context.Context
	ApiService             *ChannelApiService
	channelId              string
	putChannelTopicRequest *PutChannelTopicRequest
}

func (r ChannelApiEditChannelTopicRequest) PutChannelTopicRequest(putChannelTopicRequest PutChannelTopicRequest) ChannelApiEditChannelTopicRequest {
	r.putChannelTopicRequest = &putChannelTopicRequest
	return r
}

func (r ChannelApiEditChannelTopicRequest) Execute() (*http.Response, error) {
	return r.ApiService.EditChannelTopicExecute(r)
}

/*
EditChannelTopic チャンネルトピックを編集

指定したチャンネルのトピックを編集します。
アーカイブされているチャンネルのトピックは編集できません。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId チャンネルUUID
	@return ChannelApiEditChannelTopicRequest
*/
func (a *ChannelApiService) EditChannelTopic(ctx context.Context, channelId string) ChannelApiEditChannelTopicRequest {
	return ChannelApiEditChannelTopicRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *ChannelApiService) EditChannelTopicExecute(r ChannelApiEditChannelTopicRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.EditChannelTopic")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}/topic"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.putChannelTopicRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChannelApiGetChannelRequest struct {
	ctx        context.Context
	ApiService *ChannelApiService
	channelId  string
}

func (r ChannelApiGetChannelRequest) Execute() (*Channel, *http.Response, error) {
	return r.ApiService.GetChannelExecute(r)
}

/*
GetChannel チャンネル情報を取得

指定したチャンネルの情報を取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId チャンネルUUID
	@return ChannelApiGetChannelRequest
*/
func (a *ChannelApiService) GetChannel(ctx context.Context, channelId string) ChannelApiGetChannelRequest {
	return ChannelApiGetChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return Channel
func (a *ChannelApiService) GetChannelExecute(r ChannelApiGetChannelRequest) (*Channel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Channel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelBotsRequest struct {
	ctx        context.Context
	ApiService *ChannelApiService
	channelId  string
}

func (r ChannelApiGetChannelBotsRequest) Execute() ([]BotUser, *http.Response, error) {
	return r.ApiService.GetChannelBotsExecute(r)
}

/*
GetChannelBots チャンネル参加中のBOTのリストを取得

指定したチャンネルに参加しているBOTのリストを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId チャンネルUUID
	@return ChannelApiGetChannelBotsRequest
*/
func (a *ChannelApiService) GetChannelBots(ctx context.Context, channelId string) ChannelApiGetChannelBotsRequest {
	return ChannelApiGetChannelBotsRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return []BotUser
func (a *ChannelApiService) GetChannelBotsExecute(r ChannelApiGetChannelBotsRequest) ([]BotUser, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BotUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelBots")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}/bots"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelEventsRequest struct {
	ctx        context.Context
	ApiService *ChannelApiService
	channelId  string
	limit      *int32
	offset     *int32
	since      *time.Time
	until      *time.Time
	inclusive  *bool
	order      *string
}

// 取得する件数
func (r ChannelApiGetChannelEventsRequest) Limit(limit int32) ChannelApiGetChannelEventsRequest {
	r.limit = &limit
	return r
}

// 取得するオフセット
func (r ChannelApiGetChannelEventsRequest) Offset(offset int32) ChannelApiGetChannelEventsRequest {
	r.offset = &offset
	return r
}

// 取得する時間範囲の開始日時
func (r ChannelApiGetChannelEventsRequest) Since(since time.Time) ChannelApiGetChannelEventsRequest {
	r.since = &since
	return r
}

// 取得する時間範囲の終了日時
func (r ChannelApiGetChannelEventsRequest) Until(until time.Time) ChannelApiGetChannelEventsRequest {
	r.until = &until
	return r
}

// 範囲の端を含めるかどうか
func (r ChannelApiGetChannelEventsRequest) Inclusive(inclusive bool) ChannelApiGetChannelEventsRequest {
	r.inclusive = &inclusive
	return r
}

// 昇順か降順か
func (r ChannelApiGetChannelEventsRequest) Order(order string) ChannelApiGetChannelEventsRequest {
	r.order = &order
	return r
}

func (r ChannelApiGetChannelEventsRequest) Execute() ([]ChannelEvent, *http.Response, error) {
	return r.ApiService.GetChannelEventsExecute(r)
}

/*
GetChannelEvents チャンネルイベントのリストを取得

指定したチャンネルのイベントリストを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId チャンネルUUID
	@return ChannelApiGetChannelEventsRequest
*/
func (a *ChannelApiService) GetChannelEvents(ctx context.Context, channelId string) ChannelApiGetChannelEventsRequest {
	return ChannelApiGetChannelEventsRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return []ChannelEvent
func (a *ChannelApiService) GetChannelEventsExecute(r ChannelApiGetChannelEventsRequest) ([]ChannelEvent, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ChannelEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "")
	}
	if r.until != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "until", r.until, "")
	}
	if r.inclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclusive", r.inclusive, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelPinsRequest struct {
	ctx        context.Context
	ApiService *ChannelApiService
	channelId  string
}

func (r ChannelApiGetChannelPinsRequest) Execute() ([]Pin, *http.Response, error) {
	return r.ApiService.GetChannelPinsExecute(r)
}

/*
GetChannelPins チャンネルピンのリストを取得

指定したチャンネルにピン留めされているピンメッセージのリストを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId チャンネルUUID
	@return ChannelApiGetChannelPinsRequest
*/
func (a *ChannelApiService) GetChannelPins(ctx context.Context, channelId string) ChannelApiGetChannelPinsRequest {
	return ChannelApiGetChannelPinsRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return []Pin
func (a *ChannelApiService) GetChannelPinsExecute(r ChannelApiGetChannelPinsRequest) ([]Pin, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Pin
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelPins")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}/pins"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelStatsRequest struct {
	ctx        context.Context
	ApiService *ChannelApiService
	channelId  string
}

func (r ChannelApiGetChannelStatsRequest) Execute() (*ChannelStats, *http.Response, error) {
	return r.ApiService.GetChannelStatsExecute(r)
}

/*
GetChannelStats チャンネル統計情報を取得

指定したチャンネルの統計情報を取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId チャンネルUUID
	@return ChannelApiGetChannelStatsRequest
*/
func (a *ChannelApiService) GetChannelStats(ctx context.Context, channelId string) ChannelApiGetChannelStatsRequest {
	return ChannelApiGetChannelStatsRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return ChannelStats
func (a *ChannelApiService) GetChannelStatsExecute(r ChannelApiGetChannelStatsRequest) (*ChannelStats, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ChannelStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelSubscribersRequest struct {
	ctx        context.Context
	ApiService *ChannelApiService
	channelId  string
}

func (r ChannelApiGetChannelSubscribersRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetChannelSubscribersExecute(r)
}

/*
GetChannelSubscribers チャンネルの通知購読者のリストを取得

指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId チャンネルUUID
	@return ChannelApiGetChannelSubscribersRequest
*/
func (a *ChannelApiService) GetChannelSubscribers(ctx context.Context, channelId string) ChannelApiGetChannelSubscribersRequest {
	return ChannelApiGetChannelSubscribersRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return []string
func (a *ChannelApiService) GetChannelSubscribersExecute(r ChannelApiGetChannelSubscribersRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelSubscribers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}/subscribers"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelTopicRequest struct {
	ctx        context.Context
	ApiService *ChannelApiService
	channelId  string
}

func (r ChannelApiGetChannelTopicRequest) Execute() (*ChannelTopic, *http.Response, error) {
	return r.ApiService.GetChannelTopicExecute(r)
}

/*
GetChannelTopic チャンネルトピックを取得

指定したチャンネルのトピックを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId チャンネルUUID
	@return ChannelApiGetChannelTopicRequest
*/
func (a *ChannelApiService) GetChannelTopic(ctx context.Context, channelId string) ChannelApiGetChannelTopicRequest {
	return ChannelApiGetChannelTopicRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return ChannelTopic
func (a *ChannelApiService) GetChannelTopicExecute(r ChannelApiGetChannelTopicRequest) (*ChannelTopic, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ChannelTopic
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelTopic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}/topic"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelViewersRequest struct {
	ctx        context.Context
	ApiService *ChannelApiService
	channelId  string
}

func (r ChannelApiGetChannelViewersRequest) Execute() ([]ChannelViewer, *http.Response, error) {
	return r.ApiService.GetChannelViewersExecute(r)
}

/*
GetChannelViewers チャンネル閲覧者リストを取得

指定したチャンネルの閲覧者のリストを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId チャンネルUUID
	@return ChannelApiGetChannelViewersRequest
*/
func (a *ChannelApiService) GetChannelViewers(ctx context.Context, channelId string) ChannelApiGetChannelViewersRequest {
	return ChannelApiGetChannelViewersRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return []ChannelViewer
func (a *ChannelApiService) GetChannelViewersExecute(r ChannelApiGetChannelViewersRequest) ([]ChannelViewer, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ChannelViewer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelViewers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}/viewers"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelsRequest struct {
	ctx        context.Context
	ApiService *ChannelApiService
	includeDm  *bool
}

// ダイレクトメッセージチャンネルをレスポンスに含めるかどうか
func (r ChannelApiGetChannelsRequest) IncludeDm(includeDm bool) ChannelApiGetChannelsRequest {
	r.includeDm = &includeDm
	return r
}

func (r ChannelApiGetChannelsRequest) Execute() (*ChannelList, *http.Response, error) {
	return r.ApiService.GetChannelsExecute(r)
}

/*
GetChannels チャンネルリストを取得

チャンネルのリストを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ChannelApiGetChannelsRequest
*/
func (a *ChannelApiService) GetChannels(ctx context.Context) ChannelApiGetChannelsRequest {
	return ChannelApiGetChannelsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ChannelList
func (a *ChannelApiService) GetChannelsExecute(r ChannelApiGetChannelsRequest) (*ChannelList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ChannelList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeDm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-dm", r.includeDm, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetMessagesRequest struct {
	ctx        context.Context
	ApiService *ChannelApiService
	channelId  string
	limit      *int32
	offset     *int32
	since      *time.Time
	until      *time.Time
	inclusive  *bool
	order      *string
}

// 取得する件数
func (r ChannelApiGetMessagesRequest) Limit(limit int32) ChannelApiGetMessagesRequest {
	r.limit = &limit
	return r
}

// 取得するオフセット
func (r ChannelApiGetMessagesRequest) Offset(offset int32) ChannelApiGetMessagesRequest {
	r.offset = &offset
	return r
}

// 取得する時間範囲の開始日時
func (r ChannelApiGetMessagesRequest) Since(since time.Time) ChannelApiGetMessagesRequest {
	r.since = &since
	return r
}

// 取得する時間範囲の終了日時
func (r ChannelApiGetMessagesRequest) Until(until time.Time) ChannelApiGetMessagesRequest {
	r.until = &until
	return r
}

// 範囲の端を含めるかどうか
func (r ChannelApiGetMessagesRequest) Inclusive(inclusive bool) ChannelApiGetMessagesRequest {
	r.inclusive = &inclusive
	return r
}

// 昇順か降順か
func (r ChannelApiGetMessagesRequest) Order(order string) ChannelApiGetMessagesRequest {
	r.order = &order
	return r
}

func (r ChannelApiGetMessagesRequest) Execute() ([]Message, *http.Response, error) {
	return r.ApiService.GetMessagesExecute(r)
}

/*
GetMessages チャンネルメッセージのリストを取得

指定したチャンネルのメッセージのリストを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId チャンネルUUID
	@return ChannelApiGetMessagesRequest
*/
func (a *ChannelApiService) GetMessages(ctx context.Context, channelId string) ChannelApiGetMessagesRequest {
	return ChannelApiGetMessagesRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return []Message
func (a *ChannelApiService) GetMessagesExecute(r ChannelApiGetMessagesRequest) ([]Message, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "")
	}
	if r.until != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "until", r.until, "")
	}
	if r.inclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclusive", r.inclusive, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetUserDMChannelRequest struct {
	ctx        context.Context
	ApiService *ChannelApiService
	userId     string
}

func (r ChannelApiGetUserDMChannelRequest) Execute() (*DMChannel, *http.Response, error) {
	return r.ApiService.GetUserDMChannelExecute(r)
}

/*
GetUserDMChannel DMチャンネル情報を取得

指定したユーザーとのダイレクトメッセージチャンネルの情報を返します。
ダイレクトメッセージチャンネルが存在しなかった場合、自動的に作成されます。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId
	@return ChannelApiGetUserDMChannelRequest
*/
func (a *ChannelApiService) GetUserDMChannel(ctx context.Context, userId string) ChannelApiGetUserDMChannelRequest {
	return ChannelApiGetUserDMChannelRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return DMChannel
func (a *ChannelApiService) GetUserDMChannelExecute(r ChannelApiGetUserDMChannelRequest) (*DMChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DMChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetUserDMChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{userId}/dm-channel"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostMessageRequest struct {
	ctx                context.Context
	ApiService         *ChannelApiService
	channelId          string
	postMessageRequest *PostMessageRequest
}

func (r ChannelApiPostMessageRequest) PostMessageRequest(postMessageRequest PostMessageRequest) ChannelApiPostMessageRequest {
	r.postMessageRequest = &postMessageRequest
	return r
}

func (r ChannelApiPostMessageRequest) Execute() (*Message, *http.Response, error) {
	return r.ApiService.PostMessageExecute(r)
}

/*
PostMessage チャンネルにメッセージを投稿

指定したチャンネルにメッセージを投稿します。
embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。
アーカイブされているチャンネルに投稿することはできません。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId チャンネルUUID
	@return ChannelApiPostMessageRequest
*/
func (a *ChannelApiService) PostMessage(ctx context.Context, channelId string) ChannelApiPostMessageRequest {
	return ChannelApiPostMessageRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return Message
func (a *ChannelApiService) PostMessageExecute(r ChannelApiPostMessageRequest) (*Message, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postMessageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiSetChannelSubscribersRequest struct {
	ctx                          context.Context
	ApiService                   *ChannelApiService
	channelId                    string
	putChannelSubscribersRequest *PutChannelSubscribersRequest
}

func (r ChannelApiSetChannelSubscribersRequest) PutChannelSubscribersRequest(putChannelSubscribersRequest PutChannelSubscribersRequest) ChannelApiSetChannelSubscribersRequest {
	r.putChannelSubscribersRequest = &putChannelSubscribersRequest
	return r
}

func (r ChannelApiSetChannelSubscribersRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetChannelSubscribersExecute(r)
}

/*
SetChannelSubscribers チャンネルの通知購読者を設定

指定したチャンネルの通知購読者を設定します。
リクエストに含めなかったユーザーの通知購読状態はオフになります。
また、存在しないユーザーを指定した場合は無視されます。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId チャンネルUUID
	@return ChannelApiSetChannelSubscribersRequest
*/
func (a *ChannelApiService) SetChannelSubscribers(ctx context.Context, channelId string) ChannelApiSetChannelSubscribersRequest {
	return ChannelApiSetChannelSubscribersRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *ChannelApiService) SetChannelSubscribersExecute(r ChannelApiSetChannelSubscribersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.SetChannelSubscribers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}/subscribers"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.putChannelSubscribersRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
