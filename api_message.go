/*
traQ v3

traQ v3 API

API version: 3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package traq

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// MessageApiService MessageApi service
type MessageApiService service

type MessageApiAddMessageStampRequest struct {
	ctx                     context.Context
	ApiService              *MessageApiService
	messageId               string
	stampId                 string
	postMessageStampRequest *PostMessageStampRequest
}

func (r MessageApiAddMessageStampRequest) PostMessageStampRequest(postMessageStampRequest PostMessageStampRequest) MessageApiAddMessageStampRequest {
	r.postMessageStampRequest = &postMessageStampRequest
	return r
}

func (r MessageApiAddMessageStampRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddMessageStampExecute(r)
}

/*
AddMessageStamp スタンプを押す

指定したメッセージに指定したスタンプを押します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@param stampId スタンプUUID
	@return MessageApiAddMessageStampRequest
*/
func (a *MessageApiService) AddMessageStamp(ctx context.Context, messageId string, stampId string) MessageApiAddMessageStampRequest {
	return MessageApiAddMessageStampRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
		stampId:    stampId,
	}
}

// Execute executes the request
func (a *MessageApiService) AddMessageStampExecute(r MessageApiAddMessageStampRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageApiService.AddMessageStamp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}/stamps/{stampId}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stampId"+"}", url.PathEscape(parameterValueToString(r.stampId, "stampId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postMessageStampRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MessageApiCreatePinRequest struct {
	ctx        context.Context
	ApiService *MessageApiService
	messageId  string
}

func (r MessageApiCreatePinRequest) Execute() (*MessagePin, *http.Response, error) {
	return r.ApiService.CreatePinExecute(r)
}

/*
CreatePin ピン留めする

指定したメッセージをピン留めします。
アーカイブされているチャンネルのメッセージ・存在しないメッセージ・チャンネル当たりの上限数を超えたメッセージのピン留めはできません。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@return MessageApiCreatePinRequest
*/
func (a *MessageApiService) CreatePin(ctx context.Context, messageId string) MessageApiCreatePinRequest {
	return MessageApiCreatePinRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
//
//	@return MessagePin
func (a *MessageApiService) CreatePinExecute(r MessageApiCreatePinRequest) (*MessagePin, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MessagePin
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageApiService.CreatePin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}/pin"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MessageApiDeleteMessageRequest struct {
	ctx        context.Context
	ApiService *MessageApiService
	messageId  string
}

func (r MessageApiDeleteMessageRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteMessageExecute(r)
}

/*
DeleteMessage メッセージを削除

指定したメッセージを削除します。
自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ削除することができます。
アーカイブされているチャンネルのメッセージを編集することは出来ません。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@return MessageApiDeleteMessageRequest
*/
func (a *MessageApiService) DeleteMessage(ctx context.Context, messageId string) MessageApiDeleteMessageRequest {
	return MessageApiDeleteMessageRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
func (a *MessageApiService) DeleteMessageExecute(r MessageApiDeleteMessageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageApiService.DeleteMessage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MessageApiEditMessageRequest struct {
	ctx                context.Context
	ApiService         *MessageApiService
	messageId          string
	postMessageRequest *PostMessageRequest
}

func (r MessageApiEditMessageRequest) PostMessageRequest(postMessageRequest PostMessageRequest) MessageApiEditMessageRequest {
	r.postMessageRequest = &postMessageRequest
	return r
}

func (r MessageApiEditMessageRequest) Execute() (*http.Response, error) {
	return r.ApiService.EditMessageExecute(r)
}

/*
EditMessage メッセージを編集

指定したメッセージを編集します。
自身が投稿したメッセージのみ編集することができます。
アーカイブされているチャンネルのメッセージを編集することは出来ません。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@return MessageApiEditMessageRequest
*/
func (a *MessageApiService) EditMessage(ctx context.Context, messageId string) MessageApiEditMessageRequest {
	return MessageApiEditMessageRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
func (a *MessageApiService) EditMessageExecute(r MessageApiEditMessageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageApiService.EditMessage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postMessageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MessageApiGetDirectMessagesRequest struct {
	ctx        context.Context
	ApiService *MessageApiService
	userId     string
	limit      *int32
	offset     *int32
	since      *time.Time
	until      *time.Time
	inclusive  *bool
	order      *string
}

// 取得する件数
func (r MessageApiGetDirectMessagesRequest) Limit(limit int32) MessageApiGetDirectMessagesRequest {
	r.limit = &limit
	return r
}

// 取得するオフセット
func (r MessageApiGetDirectMessagesRequest) Offset(offset int32) MessageApiGetDirectMessagesRequest {
	r.offset = &offset
	return r
}

// 取得する時間範囲の開始日時
func (r MessageApiGetDirectMessagesRequest) Since(since time.Time) MessageApiGetDirectMessagesRequest {
	r.since = &since
	return r
}

// 取得する時間範囲の終了日時
func (r MessageApiGetDirectMessagesRequest) Until(until time.Time) MessageApiGetDirectMessagesRequest {
	r.until = &until
	return r
}

// 範囲の端を含めるかどうか
func (r MessageApiGetDirectMessagesRequest) Inclusive(inclusive bool) MessageApiGetDirectMessagesRequest {
	r.inclusive = &inclusive
	return r
}

// 昇順か降順か
func (r MessageApiGetDirectMessagesRequest) Order(order string) MessageApiGetDirectMessagesRequest {
	r.order = &order
	return r
}

func (r MessageApiGetDirectMessagesRequest) Execute() ([]Message, *http.Response, error) {
	return r.ApiService.GetDirectMessagesExecute(r)
}

/*
GetDirectMessages ダイレクトメッセージのリストを取得

指定したユーザーとのダイレクトメッセージのリストを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId ユーザーUUID
	@return MessageApiGetDirectMessagesRequest
*/
func (a *MessageApiService) GetDirectMessages(ctx context.Context, userId string) MessageApiGetDirectMessagesRequest {
	return MessageApiGetDirectMessagesRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return []Message
func (a *MessageApiService) GetDirectMessagesExecute(r MessageApiGetDirectMessagesRequest) ([]Message, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageApiService.GetDirectMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{userId}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "")
	}
	if r.until != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "until", r.until, "")
	}
	if r.inclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclusive", r.inclusive, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MessageApiGetMessageRequest struct {
	ctx        context.Context
	ApiService *MessageApiService
	messageId  string
}

func (r MessageApiGetMessageRequest) Execute() (*Message, *http.Response, error) {
	return r.ApiService.GetMessageExecute(r)
}

/*
GetMessage メッセージを取得

指定したメッセージを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@return MessageApiGetMessageRequest
*/
func (a *MessageApiService) GetMessage(ctx context.Context, messageId string) MessageApiGetMessageRequest {
	return MessageApiGetMessageRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
//
//	@return Message
func (a *MessageApiService) GetMessageExecute(r MessageApiGetMessageRequest) (*Message, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageApiService.GetMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MessageApiGetMessageClipsRequest struct {
	ctx        context.Context
	ApiService *MessageApiService
	messageId  string
}

func (r MessageApiGetMessageClipsRequest) Execute() ([]MessageClip, *http.Response, error) {
	return r.ApiService.GetMessageClipsExecute(r)
}

/*
GetMessageClips 自分のクリップを取得

対象のメッセージの自分のクリップの一覧を返します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@return MessageApiGetMessageClipsRequest
*/
func (a *MessageApiService) GetMessageClips(ctx context.Context, messageId string) MessageApiGetMessageClipsRequest {
	return MessageApiGetMessageClipsRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
//
//	@return []MessageClip
func (a *MessageApiService) GetMessageClipsExecute(r MessageApiGetMessageClipsRequest) ([]MessageClip, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []MessageClip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageApiService.GetMessageClips")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}/clips"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MessageApiGetMessageStampsRequest struct {
	ctx        context.Context
	ApiService *MessageApiService
	messageId  string
}

func (r MessageApiGetMessageStampsRequest) Execute() ([]MessageStamp, *http.Response, error) {
	return r.ApiService.GetMessageStampsExecute(r)
}

/*
GetMessageStamps メッセージのスタンプリストを取得

指定したメッセージに押されているスタンプのリストを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@return MessageApiGetMessageStampsRequest
*/
func (a *MessageApiService) GetMessageStamps(ctx context.Context, messageId string) MessageApiGetMessageStampsRequest {
	return MessageApiGetMessageStampsRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
//
//	@return []MessageStamp
func (a *MessageApiService) GetMessageStampsExecute(r MessageApiGetMessageStampsRequest) ([]MessageStamp, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []MessageStamp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageApiService.GetMessageStamps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}/stamps"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MessageApiGetMessagesRequest struct {
	ctx        context.Context
	ApiService *MessageApiService
	channelId  string
	limit      *int32
	offset     *int32
	since      *time.Time
	until      *time.Time
	inclusive  *bool
	order      *string
}

// 取得する件数
func (r MessageApiGetMessagesRequest) Limit(limit int32) MessageApiGetMessagesRequest {
	r.limit = &limit
	return r
}

// 取得するオフセット
func (r MessageApiGetMessagesRequest) Offset(offset int32) MessageApiGetMessagesRequest {
	r.offset = &offset
	return r
}

// 取得する時間範囲の開始日時
func (r MessageApiGetMessagesRequest) Since(since time.Time) MessageApiGetMessagesRequest {
	r.since = &since
	return r
}

// 取得する時間範囲の終了日時
func (r MessageApiGetMessagesRequest) Until(until time.Time) MessageApiGetMessagesRequest {
	r.until = &until
	return r
}

// 範囲の端を含めるかどうか
func (r MessageApiGetMessagesRequest) Inclusive(inclusive bool) MessageApiGetMessagesRequest {
	r.inclusive = &inclusive
	return r
}

// 昇順か降順か
func (r MessageApiGetMessagesRequest) Order(order string) MessageApiGetMessagesRequest {
	r.order = &order
	return r
}

func (r MessageApiGetMessagesRequest) Execute() ([]Message, *http.Response, error) {
	return r.ApiService.GetMessagesExecute(r)
}

/*
GetMessages チャンネルメッセージのリストを取得

指定したチャンネルのメッセージのリストを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId チャンネルUUID
	@return MessageApiGetMessagesRequest
*/
func (a *MessageApiService) GetMessages(ctx context.Context, channelId string) MessageApiGetMessagesRequest {
	return MessageApiGetMessagesRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return []Message
func (a *MessageApiService) GetMessagesExecute(r MessageApiGetMessagesRequest) ([]Message, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageApiService.GetMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "")
	}
	if r.until != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "until", r.until, "")
	}
	if r.inclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclusive", r.inclusive, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MessageApiGetPinRequest struct {
	ctx        context.Context
	ApiService *MessageApiService
	messageId  string
}

func (r MessageApiGetPinRequest) Execute() (*MessagePin, *http.Response, error) {
	return r.ApiService.GetPinExecute(r)
}

/*
GetPin ピン留めを取得

指定したメッセージのピン留め情報を取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@return MessageApiGetPinRequest
*/
func (a *MessageApiService) GetPin(ctx context.Context, messageId string) MessageApiGetPinRequest {
	return MessageApiGetPinRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
//
//	@return MessagePin
func (a *MessageApiService) GetPinExecute(r MessageApiGetPinRequest) (*MessagePin, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MessagePin
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageApiService.GetPin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}/pin"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MessageApiPostDirectMessageRequest struct {
	ctx                context.Context
	ApiService         *MessageApiService
	userId             string
	postMessageRequest *PostMessageRequest
}

func (r MessageApiPostDirectMessageRequest) PostMessageRequest(postMessageRequest PostMessageRequest) MessageApiPostDirectMessageRequest {
	r.postMessageRequest = &postMessageRequest
	return r
}

func (r MessageApiPostDirectMessageRequest) Execute() (*Message, *http.Response, error) {
	return r.ApiService.PostDirectMessageExecute(r)
}

/*
PostDirectMessage ダイレクトメッセージを送信

指定したユーザーにダイレクトメッセージを送信します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId ユーザーUUID
	@return MessageApiPostDirectMessageRequest
*/
func (a *MessageApiService) PostDirectMessage(ctx context.Context, userId string) MessageApiPostDirectMessageRequest {
	return MessageApiPostDirectMessageRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return Message
func (a *MessageApiService) PostDirectMessageExecute(r MessageApiPostDirectMessageRequest) (*Message, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageApiService.PostDirectMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{userId}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postMessageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MessageApiPostMessageRequest struct {
	ctx                context.Context
	ApiService         *MessageApiService
	channelId          string
	postMessageRequest *PostMessageRequest
}

func (r MessageApiPostMessageRequest) PostMessageRequest(postMessageRequest PostMessageRequest) MessageApiPostMessageRequest {
	r.postMessageRequest = &postMessageRequest
	return r
}

func (r MessageApiPostMessageRequest) Execute() (*Message, *http.Response, error) {
	return r.ApiService.PostMessageExecute(r)
}

/*
PostMessage チャンネルにメッセージを投稿

指定したチャンネルにメッセージを投稿します。
embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。
アーカイブされているチャンネルに投稿することはできません。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId チャンネルUUID
	@return MessageApiPostMessageRequest
*/
func (a *MessageApiService) PostMessage(ctx context.Context, channelId string) MessageApiPostMessageRequest {
	return MessageApiPostMessageRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return Message
func (a *MessageApiService) PostMessageExecute(r MessageApiPostMessageRequest) (*Message, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageApiService.PostMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postMessageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MessageApiRemoveMessageStampRequest struct {
	ctx        context.Context
	ApiService *MessageApiService
	messageId  string
	stampId    string
}

func (r MessageApiRemoveMessageStampRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveMessageStampExecute(r)
}

/*
RemoveMessageStamp スタンプを消す

指定したメッセージから指定した自身が押したスタンプを削除します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@param stampId スタンプUUID
	@return MessageApiRemoveMessageStampRequest
*/
func (a *MessageApiService) RemoveMessageStamp(ctx context.Context, messageId string, stampId string) MessageApiRemoveMessageStampRequest {
	return MessageApiRemoveMessageStampRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
		stampId:    stampId,
	}
}

// Execute executes the request
func (a *MessageApiService) RemoveMessageStampExecute(r MessageApiRemoveMessageStampRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageApiService.RemoveMessageStamp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}/stamps/{stampId}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stampId"+"}", url.PathEscape(parameterValueToString(r.stampId, "stampId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MessageApiRemovePinRequest struct {
	ctx        context.Context
	ApiService *MessageApiService
	messageId  string
}

func (r MessageApiRemovePinRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemovePinExecute(r)
}

/*
RemovePin ピン留めを外す

指定したメッセージのピン留めを外します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@return MessageApiRemovePinRequest
*/
func (a *MessageApiService) RemovePin(ctx context.Context, messageId string) MessageApiRemovePinRequest {
	return MessageApiRemovePinRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
func (a *MessageApiService) RemovePinExecute(r MessageApiRemovePinRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageApiService.RemovePin")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}/pin"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MessageApiSearchMessagesRequest struct {
	ctx            context.Context
	ApiService     *MessageApiService
	word           *string
	after          *time.Time
	before         *time.Time
	in             *string
	to             *string
	from           *string
	citation       *string
	bot            *bool
	hasURL         *bool
	hasAttachments *bool
	hasImage       *bool
	hasVideo       *bool
	hasAudio       *bool
	limit          *int32
	offset         *int32
	sort           *string
}

// 検索ワード Simple-Query-String-Syntaxをパースして検索します
func (r MessageApiSearchMessagesRequest) Word(word string) MessageApiSearchMessagesRequest {
	r.word = &word
	return r
}

// 投稿日時が指定日時より後
func (r MessageApiSearchMessagesRequest) After(after time.Time) MessageApiSearchMessagesRequest {
	r.after = &after
	return r
}

// 投稿日時が指定日時より前
func (r MessageApiSearchMessagesRequest) Before(before time.Time) MessageApiSearchMessagesRequest {
	r.before = &before
	return r
}

// メッセージが投稿されたチャンネル
func (r MessageApiSearchMessagesRequest) In(in string) MessageApiSearchMessagesRequest {
	r.in = &in
	return r
}

// メンションされたユーザー
func (r MessageApiSearchMessagesRequest) To(to string) MessageApiSearchMessagesRequest {
	r.to = &to
	return r
}

// メッセージを投稿したユーザー
func (r MessageApiSearchMessagesRequest) From(from string) MessageApiSearchMessagesRequest {
	r.from = &from
	return r
}

// 引用しているメッセージ
func (r MessageApiSearchMessagesRequest) Citation(citation string) MessageApiSearchMessagesRequest {
	r.citation = &citation
	return r
}

// メッセージを投稿したユーザーがBotかどうか
func (r MessageApiSearchMessagesRequest) Bot(bot bool) MessageApiSearchMessagesRequest {
	r.bot = &bot
	return r
}

// メッセージがURLを含むか
func (r MessageApiSearchMessagesRequest) HasURL(hasURL bool) MessageApiSearchMessagesRequest {
	r.hasURL = &hasURL
	return r
}

// メッセージが添付ファイルを含むか
func (r MessageApiSearchMessagesRequest) HasAttachments(hasAttachments bool) MessageApiSearchMessagesRequest {
	r.hasAttachments = &hasAttachments
	return r
}

// メッセージが画像を含むか
func (r MessageApiSearchMessagesRequest) HasImage(hasImage bool) MessageApiSearchMessagesRequest {
	r.hasImage = &hasImage
	return r
}

// メッセージが動画を含むか
func (r MessageApiSearchMessagesRequest) HasVideo(hasVideo bool) MessageApiSearchMessagesRequest {
	r.hasVideo = &hasVideo
	return r
}

// メッセージが音声ファイルを含むか
func (r MessageApiSearchMessagesRequest) HasAudio(hasAudio bool) MessageApiSearchMessagesRequest {
	r.hasAudio = &hasAudio
	return r
}

// 検索結果から取得するメッセージの最大件数
func (r MessageApiSearchMessagesRequest) Limit(limit int32) MessageApiSearchMessagesRequest {
	r.limit = &limit
	return r
}

// 検索結果から取得するメッセージのオフセット
func (r MessageApiSearchMessagesRequest) Offset(offset int32) MessageApiSearchMessagesRequest {
	r.offset = &offset
	return r
}

// ソート順 (作成日時が新しい &#x60;createdAt&#x60;, 作成日時が古い &#x60;-createdAt&#x60;, 更新日時が新しい &#x60;updatedAt&#x60;, 更新日時が古い &#x60;-updatedAt&#x60;)
func (r MessageApiSearchMessagesRequest) Sort(sort string) MessageApiSearchMessagesRequest {
	r.sort = &sort
	return r
}

func (r MessageApiSearchMessagesRequest) Execute() (*MessageSearchResult, *http.Response, error) {
	return r.ApiService.SearchMessagesExecute(r)
}

/*
SearchMessages メッセージを検索

メッセージを検索します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return MessageApiSearchMessagesRequest
*/
func (a *MessageApiService) SearchMessages(ctx context.Context) MessageApiSearchMessagesRequest {
	return MessageApiSearchMessagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MessageSearchResult
func (a *MessageApiService) SearchMessagesExecute(r MessageApiSearchMessagesRequest) (*MessageSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MessageSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageApiService.SearchMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.word != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "word", r.word, "")
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "")
	}
	if r.in != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "in", r.in, "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	}
	if r.citation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "citation", r.citation, "")
	}
	if r.bot != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bot", r.bot, "")
	}
	if r.hasURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasURL", r.hasURL, "")
	}
	if r.hasAttachments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasAttachments", r.hasAttachments, "")
	}
	if r.hasImage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasImage", r.hasImage, "")
	}
	if r.hasVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasVideo", r.hasVideo, "")
	}
	if r.hasAudio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasAudio", r.hasAudio, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
