/*
traQ v3

traQ v3 API

API version: 3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package traq

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
	"time"
)

// MessageAPIService MessageAPI service
type MessageAPIService service

type MessageAPIAddMessageStampRequest struct {
	ctx                     context.Context
	ApiService              *MessageAPIService
	messageId               string
	stampId                 string
	postMessageStampRequest *PostMessageStampRequest
}

func (r MessageAPIAddMessageStampRequest) PostMessageStampRequest(postMessageStampRequest PostMessageStampRequest) MessageAPIAddMessageStampRequest {
	r.postMessageStampRequest = &postMessageStampRequest
	return r
}

func (r MessageAPIAddMessageStampRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddMessageStampExecute(r)
}

/*
AddMessageStamp スタンプを押す

指定したメッセージに指定したスタンプを押します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@param stampId スタンプUUID
	@return MessageAPIAddMessageStampRequest
*/
func (a *MessageAPIService) AddMessageStamp(ctx context.Context, messageId string, stampId string) MessageAPIAddMessageStampRequest {
	return MessageAPIAddMessageStampRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
		stampId:    stampId,
	}
}

// Execute executes the request
func (a *MessageAPIService) AddMessageStampExecute(r MessageAPIAddMessageStampRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.AddMessageStamp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}/stamps/{stampId}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stampId"+"}", url.PathEscape(parameterValueToString(r.stampId, "stampId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postMessageStampRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MessageAPICreatePinRequest struct {
	ctx        context.Context
	ApiService *MessageAPIService
	messageId  string
}

func (r MessageAPICreatePinRequest) Execute() (*MessagePin, *http.Response, error) {
	return r.ApiService.CreatePinExecute(r)
}

/*
CreatePin ピン留めする

指定したメッセージをピン留めします。
アーカイブされているチャンネルのメッセージ・存在しないメッセージ・チャンネル当たりの上限数を超えたメッセージのピン留めはできません。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@return MessageAPICreatePinRequest
*/
func (a *MessageAPIService) CreatePin(ctx context.Context, messageId string) MessageAPICreatePinRequest {
	return MessageAPICreatePinRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
//
//	@return MessagePin
func (a *MessageAPIService) CreatePinExecute(r MessageAPICreatePinRequest) (*MessagePin, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MessagePin
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.CreatePin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}/pin"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MessageAPIDeleteMessageRequest struct {
	ctx        context.Context
	ApiService *MessageAPIService
	messageId  string
}

func (r MessageAPIDeleteMessageRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteMessageExecute(r)
}

/*
DeleteMessage メッセージを削除

指定したメッセージを削除します。
自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ削除することができます。
アーカイブされているチャンネルのメッセージを編集することは出来ません。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@return MessageAPIDeleteMessageRequest
*/
func (a *MessageAPIService) DeleteMessage(ctx context.Context, messageId string) MessageAPIDeleteMessageRequest {
	return MessageAPIDeleteMessageRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
func (a *MessageAPIService) DeleteMessageExecute(r MessageAPIDeleteMessageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.DeleteMessage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MessageAPIEditMessageRequest struct {
	ctx                context.Context
	ApiService         *MessageAPIService
	messageId          string
	postMessageRequest *PostMessageRequest
}

func (r MessageAPIEditMessageRequest) PostMessageRequest(postMessageRequest PostMessageRequest) MessageAPIEditMessageRequest {
	r.postMessageRequest = &postMessageRequest
	return r
}

func (r MessageAPIEditMessageRequest) Execute() (*http.Response, error) {
	return r.ApiService.EditMessageExecute(r)
}

/*
EditMessage メッセージを編集

指定したメッセージを編集します。
自身が投稿したメッセージのみ編集することができます。
アーカイブされているチャンネルのメッセージを編集することは出来ません。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@return MessageAPIEditMessageRequest
*/
func (a *MessageAPIService) EditMessage(ctx context.Context, messageId string) MessageAPIEditMessageRequest {
	return MessageAPIEditMessageRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
func (a *MessageAPIService) EditMessageExecute(r MessageAPIEditMessageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.EditMessage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postMessageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MessageAPIGetDirectMessagesRequest struct {
	ctx        context.Context
	ApiService *MessageAPIService
	userId     string
	limit      *int32
	offset     *int32
	since      *time.Time
	until      *time.Time
	inclusive  *bool
	order      *string
}

// 取得する件数
func (r MessageAPIGetDirectMessagesRequest) Limit(limit int32) MessageAPIGetDirectMessagesRequest {
	r.limit = &limit
	return r
}

// 取得するオフセット
func (r MessageAPIGetDirectMessagesRequest) Offset(offset int32) MessageAPIGetDirectMessagesRequest {
	r.offset = &offset
	return r
}

// 取得する時間範囲の開始日時
func (r MessageAPIGetDirectMessagesRequest) Since(since time.Time) MessageAPIGetDirectMessagesRequest {
	r.since = &since
	return r
}

// 取得する時間範囲の終了日時
func (r MessageAPIGetDirectMessagesRequest) Until(until time.Time) MessageAPIGetDirectMessagesRequest {
	r.until = &until
	return r
}

// 範囲の端を含めるかどうか
func (r MessageAPIGetDirectMessagesRequest) Inclusive(inclusive bool) MessageAPIGetDirectMessagesRequest {
	r.inclusive = &inclusive
	return r
}

// 昇順か降順か
func (r MessageAPIGetDirectMessagesRequest) Order(order string) MessageAPIGetDirectMessagesRequest {
	r.order = &order
	return r
}

func (r MessageAPIGetDirectMessagesRequest) Execute() ([]Message, *http.Response, error) {
	return r.ApiService.GetDirectMessagesExecute(r)
}

/*
GetDirectMessages ダイレクトメッセージのリストを取得

指定したユーザーとのダイレクトメッセージのリストを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId ユーザーUUID
	@return MessageAPIGetDirectMessagesRequest
*/
func (a *MessageAPIService) GetDirectMessages(ctx context.Context, userId string) MessageAPIGetDirectMessagesRequest {
	return MessageAPIGetDirectMessagesRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return []Message
func (a *MessageAPIService) GetDirectMessagesExecute(r MessageAPIGetDirectMessagesRequest) ([]Message, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.GetDirectMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{userId}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "form", "")
	} else {
		var defaultValue time.Time
		r.since = &defaultValue
	}
	if r.until != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "until", r.until, "form", "")
	}
	if r.inclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclusive", r.inclusive, "form", "")
	} else {
		var defaultValue bool = false
		r.inclusive = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
		var defaultValue string = "desc"
		r.order = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MessageAPIGetMessageRequest struct {
	ctx        context.Context
	ApiService *MessageAPIService
	messageId  string
}

func (r MessageAPIGetMessageRequest) Execute() (*Message, *http.Response, error) {
	return r.ApiService.GetMessageExecute(r)
}

/*
GetMessage メッセージを取得

指定したメッセージを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@return MessageAPIGetMessageRequest
*/
func (a *MessageAPIService) GetMessage(ctx context.Context, messageId string) MessageAPIGetMessageRequest {
	return MessageAPIGetMessageRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
//
//	@return Message
func (a *MessageAPIService) GetMessageExecute(r MessageAPIGetMessageRequest) (*Message, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.GetMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MessageAPIGetMessageClipsRequest struct {
	ctx        context.Context
	ApiService *MessageAPIService
	messageId  string
}

func (r MessageAPIGetMessageClipsRequest) Execute() ([]MessageClip, *http.Response, error) {
	return r.ApiService.GetMessageClipsExecute(r)
}

/*
GetMessageClips 自分のクリップを取得

対象のメッセージの自分のクリップの一覧を返します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@return MessageAPIGetMessageClipsRequest
*/
func (a *MessageAPIService) GetMessageClips(ctx context.Context, messageId string) MessageAPIGetMessageClipsRequest {
	return MessageAPIGetMessageClipsRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
//
//	@return []MessageClip
func (a *MessageAPIService) GetMessageClipsExecute(r MessageAPIGetMessageClipsRequest) ([]MessageClip, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []MessageClip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.GetMessageClips")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}/clips"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MessageAPIGetMessageStampsRequest struct {
	ctx        context.Context
	ApiService *MessageAPIService
	messageId  string
}

func (r MessageAPIGetMessageStampsRequest) Execute() ([]MessageStamp, *http.Response, error) {
	return r.ApiService.GetMessageStampsExecute(r)
}

/*
GetMessageStamps メッセージのスタンプリストを取得

指定したメッセージに押されているスタンプのリストを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@return MessageAPIGetMessageStampsRequest
*/
func (a *MessageAPIService) GetMessageStamps(ctx context.Context, messageId string) MessageAPIGetMessageStampsRequest {
	return MessageAPIGetMessageStampsRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
//
//	@return []MessageStamp
func (a *MessageAPIService) GetMessageStampsExecute(r MessageAPIGetMessageStampsRequest) ([]MessageStamp, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []MessageStamp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.GetMessageStamps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}/stamps"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MessageAPIGetMessagesRequest struct {
	ctx        context.Context
	ApiService *MessageAPIService
	channelId  string
	limit      *int32
	offset     *int32
	since      *time.Time
	until      *time.Time
	inclusive  *bool
	order      *string
}

// 取得する件数
func (r MessageAPIGetMessagesRequest) Limit(limit int32) MessageAPIGetMessagesRequest {
	r.limit = &limit
	return r
}

// 取得するオフセット
func (r MessageAPIGetMessagesRequest) Offset(offset int32) MessageAPIGetMessagesRequest {
	r.offset = &offset
	return r
}

// 取得する時間範囲の開始日時
func (r MessageAPIGetMessagesRequest) Since(since time.Time) MessageAPIGetMessagesRequest {
	r.since = &since
	return r
}

// 取得する時間範囲の終了日時
func (r MessageAPIGetMessagesRequest) Until(until time.Time) MessageAPIGetMessagesRequest {
	r.until = &until
	return r
}

// 範囲の端を含めるかどうか
func (r MessageAPIGetMessagesRequest) Inclusive(inclusive bool) MessageAPIGetMessagesRequest {
	r.inclusive = &inclusive
	return r
}

// 昇順か降順か
func (r MessageAPIGetMessagesRequest) Order(order string) MessageAPIGetMessagesRequest {
	r.order = &order
	return r
}

func (r MessageAPIGetMessagesRequest) Execute() ([]Message, *http.Response, error) {
	return r.ApiService.GetMessagesExecute(r)
}

/*
GetMessages チャンネルメッセージのリストを取得

指定したチャンネルのメッセージのリストを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId チャンネルUUID
	@return MessageAPIGetMessagesRequest
*/
func (a *MessageAPIService) GetMessages(ctx context.Context, channelId string) MessageAPIGetMessagesRequest {
	return MessageAPIGetMessagesRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return []Message
func (a *MessageAPIService) GetMessagesExecute(r MessageAPIGetMessagesRequest) ([]Message, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.GetMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "form", "")
	} else {
		var defaultValue time.Time
		r.since = &defaultValue
	}
	if r.until != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "until", r.until, "form", "")
	}
	if r.inclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclusive", r.inclusive, "form", "")
	} else {
		var defaultValue bool = false
		r.inclusive = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
		var defaultValue string = "desc"
		r.order = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MessageAPIGetPinRequest struct {
	ctx        context.Context
	ApiService *MessageAPIService
	messageId  string
}

func (r MessageAPIGetPinRequest) Execute() (*MessagePin, *http.Response, error) {
	return r.ApiService.GetPinExecute(r)
}

/*
GetPin ピン留めを取得

指定したメッセージのピン留め情報を取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@return MessageAPIGetPinRequest
*/
func (a *MessageAPIService) GetPin(ctx context.Context, messageId string) MessageAPIGetPinRequest {
	return MessageAPIGetPinRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
//
//	@return MessagePin
func (a *MessageAPIService) GetPinExecute(r MessageAPIGetPinRequest) (*MessagePin, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MessagePin
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.GetPin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}/pin"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MessageAPIPostDirectMessageRequest struct {
	ctx                context.Context
	ApiService         *MessageAPIService
	userId             string
	postMessageRequest *PostMessageRequest
}

func (r MessageAPIPostDirectMessageRequest) PostMessageRequest(postMessageRequest PostMessageRequest) MessageAPIPostDirectMessageRequest {
	r.postMessageRequest = &postMessageRequest
	return r
}

func (r MessageAPIPostDirectMessageRequest) Execute() (*Message, *http.Response, error) {
	return r.ApiService.PostDirectMessageExecute(r)
}

/*
PostDirectMessage ダイレクトメッセージを送信

指定したユーザーにダイレクトメッセージを送信します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId ユーザーUUID
	@return MessageAPIPostDirectMessageRequest
*/
func (a *MessageAPIService) PostDirectMessage(ctx context.Context, userId string) MessageAPIPostDirectMessageRequest {
	return MessageAPIPostDirectMessageRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return Message
func (a *MessageAPIService) PostDirectMessageExecute(r MessageAPIPostDirectMessageRequest) (*Message, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.PostDirectMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{userId}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postMessageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MessageAPIPostMessageRequest struct {
	ctx                context.Context
	ApiService         *MessageAPIService
	channelId          string
	postMessageRequest *PostMessageRequest
}

func (r MessageAPIPostMessageRequest) PostMessageRequest(postMessageRequest PostMessageRequest) MessageAPIPostMessageRequest {
	r.postMessageRequest = &postMessageRequest
	return r
}

func (r MessageAPIPostMessageRequest) Execute() (*Message, *http.Response, error) {
	return r.ApiService.PostMessageExecute(r)
}

/*
PostMessage チャンネルにメッセージを投稿

指定したチャンネルにメッセージを投稿します。
embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。
アーカイブされているチャンネルに投稿することはできません。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId チャンネルUUID
	@return MessageAPIPostMessageRequest
*/
func (a *MessageAPIService) PostMessage(ctx context.Context, channelId string) MessageAPIPostMessageRequest {
	return MessageAPIPostMessageRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return Message
func (a *MessageAPIService) PostMessageExecute(r MessageAPIPostMessageRequest) (*Message, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.PostMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postMessageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MessageAPIRemoveMessageStampRequest struct {
	ctx        context.Context
	ApiService *MessageAPIService
	messageId  string
	stampId    string
}

func (r MessageAPIRemoveMessageStampRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveMessageStampExecute(r)
}

/*
RemoveMessageStamp スタンプを消す

指定したメッセージから指定した自身が押したスタンプを削除します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@param stampId スタンプUUID
	@return MessageAPIRemoveMessageStampRequest
*/
func (a *MessageAPIService) RemoveMessageStamp(ctx context.Context, messageId string, stampId string) MessageAPIRemoveMessageStampRequest {
	return MessageAPIRemoveMessageStampRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
		stampId:    stampId,
	}
}

// Execute executes the request
func (a *MessageAPIService) RemoveMessageStampExecute(r MessageAPIRemoveMessageStampRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.RemoveMessageStamp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}/stamps/{stampId}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stampId"+"}", url.PathEscape(parameterValueToString(r.stampId, "stampId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MessageAPIRemovePinRequest struct {
	ctx        context.Context
	ApiService *MessageAPIService
	messageId  string
}

func (r MessageAPIRemovePinRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemovePinExecute(r)
}

/*
RemovePin ピン留めを外す

指定したメッセージのピン留めを外します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId メッセージUUID
	@return MessageAPIRemovePinRequest
*/
func (a *MessageAPIService) RemovePin(ctx context.Context, messageId string) MessageAPIRemovePinRequest {
	return MessageAPIRemovePinRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
func (a *MessageAPIService) RemovePinExecute(r MessageAPIRemovePinRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.RemovePin")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}/pin"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MessageAPISearchMessagesRequest struct {
	ctx            context.Context
	ApiService     *MessageAPIService
	word           *string
	after          *time.Time
	before         *time.Time
	in             *string
	to             *[]string
	from           *[]string
	citation       *string
	bot            *bool
	hasURL         *bool
	hasAttachments *bool
	hasImage       *bool
	hasVideo       *bool
	hasAudio       *bool
	limit          *int32
	offset         *int32
	sort           *string
}

// 検索ワード Simple-Query-String-Syntaxをパースして検索します
func (r MessageAPISearchMessagesRequest) Word(word string) MessageAPISearchMessagesRequest {
	r.word = &word
	return r
}

// 投稿日時が指定日時より後
func (r MessageAPISearchMessagesRequest) After(after time.Time) MessageAPISearchMessagesRequest {
	r.after = &after
	return r
}

// 投稿日時が指定日時より前
func (r MessageAPISearchMessagesRequest) Before(before time.Time) MessageAPISearchMessagesRequest {
	r.before = &before
	return r
}

// メッセージが投稿されたチャンネル
func (r MessageAPISearchMessagesRequest) In(in string) MessageAPISearchMessagesRequest {
	r.in = &in
	return r
}

// メンションされたユーザー
func (r MessageAPISearchMessagesRequest) To(to []string) MessageAPISearchMessagesRequest {
	r.to = &to
	return r
}

// メッセージを投稿したユーザー
func (r MessageAPISearchMessagesRequest) From(from []string) MessageAPISearchMessagesRequest {
	r.from = &from
	return r
}

// 引用しているメッセージ
func (r MessageAPISearchMessagesRequest) Citation(citation string) MessageAPISearchMessagesRequest {
	r.citation = &citation
	return r
}

// メッセージを投稿したユーザーがBotかどうか
func (r MessageAPISearchMessagesRequest) Bot(bot bool) MessageAPISearchMessagesRequest {
	r.bot = &bot
	return r
}

// メッセージがURLを含むか
func (r MessageAPISearchMessagesRequest) HasURL(hasURL bool) MessageAPISearchMessagesRequest {
	r.hasURL = &hasURL
	return r
}

// メッセージが添付ファイルを含むか
func (r MessageAPISearchMessagesRequest) HasAttachments(hasAttachments bool) MessageAPISearchMessagesRequest {
	r.hasAttachments = &hasAttachments
	return r
}

// メッセージが画像を含むか
func (r MessageAPISearchMessagesRequest) HasImage(hasImage bool) MessageAPISearchMessagesRequest {
	r.hasImage = &hasImage
	return r
}

// メッセージが動画を含むか
func (r MessageAPISearchMessagesRequest) HasVideo(hasVideo bool) MessageAPISearchMessagesRequest {
	r.hasVideo = &hasVideo
	return r
}

// メッセージが音声ファイルを含むか
func (r MessageAPISearchMessagesRequest) HasAudio(hasAudio bool) MessageAPISearchMessagesRequest {
	r.hasAudio = &hasAudio
	return r
}

// 検索結果から取得するメッセージの最大件数
func (r MessageAPISearchMessagesRequest) Limit(limit int32) MessageAPISearchMessagesRequest {
	r.limit = &limit
	return r
}

// 検索結果から取得するメッセージのオフセット
func (r MessageAPISearchMessagesRequest) Offset(offset int32) MessageAPISearchMessagesRequest {
	r.offset = &offset
	return r
}

// ソート順 (作成日時が新しい &#x60;createdAt&#x60;, 作成日時が古い &#x60;-createdAt&#x60;, 更新日時が新しい &#x60;updatedAt&#x60;, 更新日時が古い &#x60;-updatedAt&#x60;)
func (r MessageAPISearchMessagesRequest) Sort(sort string) MessageAPISearchMessagesRequest {
	r.sort = &sort
	return r
}

func (r MessageAPISearchMessagesRequest) Execute() (*MessageSearchResult, *http.Response, error) {
	return r.ApiService.SearchMessagesExecute(r)
}

/*
SearchMessages メッセージを検索

メッセージを検索します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return MessageAPISearchMessagesRequest
*/
func (a *MessageAPIService) SearchMessages(ctx context.Context) MessageAPISearchMessagesRequest {
	return MessageAPISearchMessagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MessageSearchResult
func (a *MessageAPIService) SearchMessagesExecute(r MessageAPISearchMessagesRequest) (*MessageSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MessageSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.SearchMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.word != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "word", r.word, "form", "")
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.in != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "in", r.in, "form", "")
	}
	if r.to != nil {
		t := *r.to
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "to", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "to", t, "form", "multi")
		}
	}
	if r.from != nil {
		t := *r.from
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "from", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "from", t, "form", "multi")
		}
	}
	if r.citation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "citation", r.citation, "form", "")
	}
	if r.bot != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bot", r.bot, "form", "")
	}
	if r.hasURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasURL", r.hasURL, "form", "")
	}
	if r.hasAttachments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasAttachments", r.hasAttachments, "form", "")
	}
	if r.hasImage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasImage", r.hasImage, "form", "")
	}
	if r.hasVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasVideo", r.hasVideo, "form", "")
	}
	if r.hasAudio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasAudio", r.hasAudio, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	} else {
		var defaultValue string = "-createdAt"
		r.sort = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
