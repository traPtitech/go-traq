/*
traQ v3

traQ v3 API

API version: 3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package traq

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// QallApiService QallApi service
type QallApiService service

type QallApiChangeParticipantRoleRequest struct {
	ctx                    context.Context
	ApiService             *QallApiService
	roomId                 string
	qallParticipantRequest *[]QallParticipantRequest
}

// 発言権限を変更する参加者の情報
func (r QallApiChangeParticipantRoleRequest) QallParticipantRequest(qallParticipantRequest []QallParticipantRequest) QallApiChangeParticipantRoleRequest {
	r.qallParticipantRequest = &qallParticipantRequest
	return r
}

func (r QallApiChangeParticipantRoleRequest) Execute() (*QallParticipantResponse, *http.Response, error) {
	return r.ApiService.ChangeParticipantRoleExecute(r)
}

/*
ChangeParticipantRole ルームでの発言権限を変更

ルーム内の参加者の発言権限を変更します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roomId ルームUUID
	@return QallApiChangeParticipantRoleRequest
*/
func (a *QallApiService) ChangeParticipantRole(ctx context.Context, roomId string) QallApiChangeParticipantRoleRequest {
	return QallApiChangeParticipantRoleRequest{
		ApiService: a,
		ctx:        ctx,
		roomId:     roomId,
	}
}

// Execute executes the request
//
//	@return QallParticipantResponse
func (a *QallApiService) ChangeParticipantRoleExecute(r QallApiChangeParticipantRoleRequest) (*QallParticipantResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QallParticipantResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallApiService.ChangeParticipantRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/rooms/{roomId}/participants"
	localVarPath = strings.Replace(localVarPath, "{"+"roomId"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.qallParticipantRequest == nil {
		return localVarReturnValue, nil, reportError("qallParticipantRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.qallParticipantRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QallApiGetLiveKitTokenRequest struct {
	ctx        context.Context
	ApiService *QallApiService
	roomId     *string
	isWebinar  *bool
}

// ルームUUID
func (r QallApiGetLiveKitTokenRequest) RoomId(roomId string) QallApiGetLiveKitTokenRequest {
	r.roomId = &roomId
	return r
}

// ウェビナールームかどうか(デフォルト false)
func (r QallApiGetLiveKitTokenRequest) IsWebinar(isWebinar bool) QallApiGetLiveKitTokenRequest {
	r.isWebinar = &isWebinar
	return r
}

func (r QallApiGetLiveKitTokenRequest) Execute() (*QallTokenResponse, *http.Response, error) {
	return r.ApiService.GetLiveKitTokenExecute(r)
}

/*
GetLiveKitToken LiveKitトークンを取得

指定したルームに参加するためのLiveKitトークンを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return QallApiGetLiveKitTokenRequest
*/
func (a *QallApiService) GetLiveKitToken(ctx context.Context) QallApiGetLiveKitTokenRequest {
	return QallApiGetLiveKitTokenRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return QallTokenResponse
func (a *QallApiService) GetLiveKitTokenExecute(r QallApiGetLiveKitTokenRequest) (*QallTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QallTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallApiService.GetLiveKitToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.isWebinar != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isWebinar", r.isWebinar, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QallApiGetQallEndpointsRequest struct {
	ctx        context.Context
	ApiService *QallApiService
}

func (r QallApiGetQallEndpointsRequest) Execute() (*QallEndpointResponse, *http.Response, error) {
	return r.ApiService.GetQallEndpointsExecute(r)
}

/*
GetQallEndpoints LiveKitエンドポイントを取得

接続可能なLiveKitエンドポイントを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return QallApiGetQallEndpointsRequest
*/
func (a *QallApiService) GetQallEndpoints(ctx context.Context) QallApiGetQallEndpointsRequest {
	return QallApiGetQallEndpointsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return QallEndpointResponse
func (a *QallApiService) GetQallEndpointsExecute(r QallApiGetQallEndpointsRequest) (*QallEndpointResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QallEndpointResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallApiService.GetQallEndpoints")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/endpoints"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QallApiGetRoomMetadataRequest struct {
	ctx        context.Context
	ApiService *QallApiService
	roomId     string
}

func (r QallApiGetRoomMetadataRequest) Execute() (*QallMetadataResponse, *http.Response, error) {
	return r.ApiService.GetRoomMetadataExecute(r)
}

/*
GetRoomMetadata ルームのメタデータを取得

ルームのメタデータを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roomId ルームUUID
	@return QallApiGetRoomMetadataRequest
*/
func (a *QallApiService) GetRoomMetadata(ctx context.Context, roomId string) QallApiGetRoomMetadataRequest {
	return QallApiGetRoomMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		roomId:     roomId,
	}
}

// Execute executes the request
//
//	@return QallMetadataResponse
func (a *QallApiService) GetRoomMetadataExecute(r QallApiGetRoomMetadataRequest) (*QallMetadataResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QallMetadataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallApiService.GetRoomMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/rooms/{roomId}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"roomId"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QallApiGetRoomsRequest struct {
	ctx        context.Context
	ApiService *QallApiService
}

func (r QallApiGetRoomsRequest) Execute() ([]QallRoomWithParticipants, *http.Response, error) {
	return r.ApiService.GetRoomsExecute(r)
}

/*
GetRooms ルームと参加者の一覧を取得

現在存在する(またはアクティブな)ルームと、そのルームに所属している参加者情報を取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return QallApiGetRoomsRequest
*/
func (a *QallApiService) GetRooms(ctx context.Context) QallApiGetRoomsRequest {
	return QallApiGetRoomsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []QallRoomWithParticipants
func (a *QallApiService) GetRoomsExecute(r QallApiGetRoomsRequest) ([]QallRoomWithParticipants, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []QallRoomWithParticipants
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallApiService.GetRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/rooms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QallApiGetSoundboardListRequest struct {
	ctx        context.Context
	ApiService *QallApiService
}

func (r QallApiGetSoundboardListRequest) Execute() ([]SoundboardItem, *http.Response, error) {
	return r.ApiService.GetSoundboardListExecute(r)
}

/*
GetSoundboardList サウンドボード用の音声一覧を取得

DBに保存されたサウンドボード情報を取得します。   各アイテムには soundId, soundName, stampId が含まれます。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return QallApiGetSoundboardListRequest
*/
func (a *QallApiService) GetSoundboardList(ctx context.Context) QallApiGetSoundboardListRequest {
	return QallApiGetSoundboardListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []SoundboardItem
func (a *QallApiService) GetSoundboardListExecute(r QallApiGetSoundboardListRequest) ([]SoundboardItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []SoundboardItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallApiService.GetSoundboardList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/soundboard"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QallApiLiveKitWebhookRequest struct {
	ctx        context.Context
	ApiService *QallApiService
	body       *map[string]interface{}
}

func (r QallApiLiveKitWebhookRequest) Body(body map[string]interface{}) QallApiLiveKitWebhookRequest {
	r.body = &body
	return r
}

func (r QallApiLiveKitWebhookRequest) Execute() (*http.Response, error) {
	return r.ApiService.LiveKitWebhookExecute(r)
}

/*
LiveKitWebhook LiveKit Webhook受信

LiveKit側で設定したWebhookから呼び出されるエンドポイントです。   参加者の入室・退出などのイベントを受け取り、サーバ内で処理を行います。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return QallApiLiveKitWebhookRequest
*/
func (a *QallApiService) LiveKitWebhook(ctx context.Context) QallApiLiveKitWebhookRequest {
	return QallApiLiveKitWebhookRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *QallApiService) LiveKitWebhookExecute(r QallApiLiveKitWebhookRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallApiService.LiveKitWebhook")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/webhook"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/webhook+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type QallApiPostSoundboardRequest struct {
	ctx        context.Context
	ApiService *QallApiService
	audio      *os.File
	soundName  *string
	stampId    *string
}

// アップロードする音声ファイル(20秒以内)
func (r QallApiPostSoundboardRequest) Audio(audio *os.File) QallApiPostSoundboardRequest {
	r.audio = audio
	return r
}

// ユーザが自由につけるサウンド名
func (r QallApiPostSoundboardRequest) SoundName(soundName string) QallApiPostSoundboardRequest {
	r.soundName = &soundName
	return r
}

// アイコンスタンプID
func (r QallApiPostSoundboardRequest) StampId(stampId string) QallApiPostSoundboardRequest {
	r.stampId = &stampId
	return r
}

func (r QallApiPostSoundboardRequest) Execute() (*SoundboardUploadResponse, *http.Response, error) {
	return r.ApiService.PostSoundboardExecute(r)
}

/*
PostSoundboard サウンドボード用の短い音声ファイルをアップロード

15秒程度の短い音声ファイルを multipart/form-data で送信し、S3(互換ストレージ)にアップロードします。   クライアントは「soundName」というフィールドを送信し、それをDBに保存して関連付けを行います。   また、サーバ側で soundId を自動生成し、S3のファイル名に使用します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return QallApiPostSoundboardRequest
*/
func (a *QallApiService) PostSoundboard(ctx context.Context) QallApiPostSoundboardRequest {
	return QallApiPostSoundboardRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SoundboardUploadResponse
func (a *QallApiService) PostSoundboardExecute(r QallApiPostSoundboardRequest) (*SoundboardUploadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SoundboardUploadResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallApiService.PostSoundboard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/soundboard"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.audio == nil {
		return localVarReturnValue, nil, reportError("audio is required and must be specified")
	}
	if r.soundName == nil {
		return localVarReturnValue, nil, reportError("soundName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var audioLocalVarFormFileName string
	var audioLocalVarFileName string
	var audioLocalVarFileBytes []byte

	audioLocalVarFormFileName = "audio"

	audioLocalVarFile := r.audio

	if audioLocalVarFile != nil {
		fbs, _ := io.ReadAll(audioLocalVarFile)

		audioLocalVarFileBytes = fbs
		audioLocalVarFileName = audioLocalVarFile.Name()
		audioLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: audioLocalVarFileBytes, fileName: audioLocalVarFileName, formFileName: audioLocalVarFormFileName})
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "soundName", r.soundName, "")
	if r.stampId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stampId", r.stampId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QallApiPostSoundboardPlayRequest struct {
	ctx                   context.Context
	ApiService            *QallApiService
	soundboardPlayRequest *SoundboardPlayRequest
}

func (r QallApiPostSoundboardPlayRequest) SoundboardPlayRequest(soundboardPlayRequest SoundboardPlayRequest) QallApiPostSoundboardPlayRequest {
	r.soundboardPlayRequest = &soundboardPlayRequest
	return r
}

func (r QallApiPostSoundboardPlayRequest) Execute() (*SoundboardPlayResponse, *http.Response, error) {
	return r.ApiService.PostSoundboardPlayExecute(r)
}

/*
PostSoundboardPlay アップロード済み音声を LiveKit ルームで再生

S3上にある音声ファイルの署名付きURLを生成し、   Ingressを介して指定ルームに音声を流します。     該当ルームに参加しているユーザであれば再生可能とします。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return QallApiPostSoundboardPlayRequest
*/
func (a *QallApiService) PostSoundboardPlay(ctx context.Context) QallApiPostSoundboardPlayRequest {
	return QallApiPostSoundboardPlayRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SoundboardPlayResponse
func (a *QallApiService) PostSoundboardPlayExecute(r QallApiPostSoundboardPlayRequest) (*SoundboardPlayResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SoundboardPlayResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallApiService.PostSoundboardPlay")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/soundboard/play"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.soundboardPlayRequest == nil {
		return localVarReturnValue, nil, reportError("soundboardPlayRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.soundboardPlayRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QallApiUpdateRoomMetadataRequest struct {
	ctx                 context.Context
	ApiService          *QallApiService
	roomId              string
	qallMetadataRequest *QallMetadataRequest
}

// ルームのメタデータ
func (r QallApiUpdateRoomMetadataRequest) QallMetadataRequest(qallMetadataRequest QallMetadataRequest) QallApiUpdateRoomMetadataRequest {
	r.qallMetadataRequest = &qallMetadataRequest
	return r
}

func (r QallApiUpdateRoomMetadataRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateRoomMetadataExecute(r)
}

/*
UpdateRoomMetadata ルームのメタデータを更新

ルームのメタデータを更新します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roomId ルームUUID
	@return QallApiUpdateRoomMetadataRequest
*/
func (a *QallApiService) UpdateRoomMetadata(ctx context.Context, roomId string) QallApiUpdateRoomMetadataRequest {
	return QallApiUpdateRoomMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		roomId:     roomId,
	}
}

// Execute executes the request
func (a *QallApiService) UpdateRoomMetadataExecute(r QallApiUpdateRoomMetadataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallApiService.UpdateRoomMetadata")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/rooms/{roomId}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"roomId"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.qallMetadataRequest == nil {
		return nil, reportError("qallMetadataRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.qallMetadataRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
