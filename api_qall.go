/*
traQ v3

traQ v3 API

API version: 3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package traq

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// QallAPIService QallAPI service
type QallAPIService service

type QallAPIChangeParticipantRoleRequest struct {
	ctx                    context.Context
	ApiService             *QallAPIService
	roomId                 string
	qallParticipantRequest *[]QallParticipantRequest
}

// 発言権限を変更する参加者の情報
func (r QallAPIChangeParticipantRoleRequest) QallParticipantRequest(qallParticipantRequest []QallParticipantRequest) QallAPIChangeParticipantRoleRequest {
	r.qallParticipantRequest = &qallParticipantRequest
	return r
}

func (r QallAPIChangeParticipantRoleRequest) Execute() (*QallParticipantResponse, *http.Response, error) {
	return r.ApiService.ChangeParticipantRoleExecute(r)
}

/*
ChangeParticipantRole ルームでの発言権限を変更

ルーム内の参加者の発言権限を変更します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roomId ルームUUID
	@return QallAPIChangeParticipantRoleRequest
*/
func (a *QallAPIService) ChangeParticipantRole(ctx context.Context, roomId string) QallAPIChangeParticipantRoleRequest {
	return QallAPIChangeParticipantRoleRequest{
		ApiService: a,
		ctx:        ctx,
		roomId:     roomId,
	}
}

// Execute executes the request
//
//	@return QallParticipantResponse
func (a *QallAPIService) ChangeParticipantRoleExecute(r QallAPIChangeParticipantRoleRequest) (*QallParticipantResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QallParticipantResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallAPIService.ChangeParticipantRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/rooms/{roomId}/participants"
	localVarPath = strings.Replace(localVarPath, "{"+"roomId"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.qallParticipantRequest == nil {
		return localVarReturnValue, nil, reportError("qallParticipantRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.qallParticipantRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QallAPIGetLiveKitTokenRequest struct {
	ctx        context.Context
	ApiService *QallAPIService
	roomId     *string
	isWebinar  *bool
}

// ルームUUID
func (r QallAPIGetLiveKitTokenRequest) RoomId(roomId string) QallAPIGetLiveKitTokenRequest {
	r.roomId = &roomId
	return r
}

// ウェビナールームかどうか(デフォルト false)
func (r QallAPIGetLiveKitTokenRequest) IsWebinar(isWebinar bool) QallAPIGetLiveKitTokenRequest {
	r.isWebinar = &isWebinar
	return r
}

func (r QallAPIGetLiveKitTokenRequest) Execute() (*QallTokenResponse, *http.Response, error) {
	return r.ApiService.GetLiveKitTokenExecute(r)
}

/*
GetLiveKitToken LiveKitトークンを取得

指定したルームに参加するためのLiveKitトークンを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return QallAPIGetLiveKitTokenRequest
*/
func (a *QallAPIService) GetLiveKitToken(ctx context.Context) QallAPIGetLiveKitTokenRequest {
	return QallAPIGetLiveKitTokenRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return QallTokenResponse
func (a *QallAPIService) GetLiveKitTokenExecute(r QallAPIGetLiveKitTokenRequest) (*QallTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QallTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallAPIService.GetLiveKitToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "form", "")
	}
	if r.isWebinar != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isWebinar", r.isWebinar, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QallAPIGetQallEndpointsRequest struct {
	ctx        context.Context
	ApiService *QallAPIService
}

func (r QallAPIGetQallEndpointsRequest) Execute() (*QallEndpointResponse, *http.Response, error) {
	return r.ApiService.GetQallEndpointsExecute(r)
}

/*
GetQallEndpoints LiveKitエンドポイントを取得

接続可能なLiveKitエンドポイントを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return QallAPIGetQallEndpointsRequest
*/
func (a *QallAPIService) GetQallEndpoints(ctx context.Context) QallAPIGetQallEndpointsRequest {
	return QallAPIGetQallEndpointsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return QallEndpointResponse
func (a *QallAPIService) GetQallEndpointsExecute(r QallAPIGetQallEndpointsRequest) (*QallEndpointResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QallEndpointResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallAPIService.GetQallEndpoints")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/endpoints"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QallAPIGetRoomMetadataRequest struct {
	ctx        context.Context
	ApiService *QallAPIService
	roomId     string
}

func (r QallAPIGetRoomMetadataRequest) Execute() (*QallMetadataResponse, *http.Response, error) {
	return r.ApiService.GetRoomMetadataExecute(r)
}

/*
GetRoomMetadata ルームのメタデータを取得

ルームのメタデータを取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roomId ルームUUID
	@return QallAPIGetRoomMetadataRequest
*/
func (a *QallAPIService) GetRoomMetadata(ctx context.Context, roomId string) QallAPIGetRoomMetadataRequest {
	return QallAPIGetRoomMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		roomId:     roomId,
	}
}

// Execute executes the request
//
//	@return QallMetadataResponse
func (a *QallAPIService) GetRoomMetadataExecute(r QallAPIGetRoomMetadataRequest) (*QallMetadataResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QallMetadataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallAPIService.GetRoomMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/rooms/{roomId}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"roomId"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QallAPIGetRoomsRequest struct {
	ctx        context.Context
	ApiService *QallAPIService
}

func (r QallAPIGetRoomsRequest) Execute() ([]QallRoomWithParticipants, *http.Response, error) {
	return r.ApiService.GetRoomsExecute(r)
}

/*
GetRooms ルームと参加者の一覧を取得

現在存在する(またはアクティブな)ルームと、そのルームに所属している参加者情報を取得します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return QallAPIGetRoomsRequest
*/
func (a *QallAPIService) GetRooms(ctx context.Context) QallAPIGetRoomsRequest {
	return QallAPIGetRoomsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []QallRoomWithParticipants
func (a *QallAPIService) GetRoomsExecute(r QallAPIGetRoomsRequest) ([]QallRoomWithParticipants, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []QallRoomWithParticipants
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallAPIService.GetRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/rooms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QallAPIGetSoundboardListRequest struct {
	ctx        context.Context
	ApiService *QallAPIService
}

func (r QallAPIGetSoundboardListRequest) Execute() ([]SoundboardItem, *http.Response, error) {
	return r.ApiService.GetSoundboardListExecute(r)
}

/*
GetSoundboardList サウンドボード用の音声一覧を取得

DBに保存されたサウンドボード情報を取得します。   各アイテムには soundId, soundName, stampId が含まれます。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return QallAPIGetSoundboardListRequest
*/
func (a *QallAPIService) GetSoundboardList(ctx context.Context) QallAPIGetSoundboardListRequest {
	return QallAPIGetSoundboardListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []SoundboardItem
func (a *QallAPIService) GetSoundboardListExecute(r QallAPIGetSoundboardListRequest) ([]SoundboardItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []SoundboardItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallAPIService.GetSoundboardList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/soundboard"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QallAPILiveKitWebhookRequest struct {
	ctx        context.Context
	ApiService *QallAPIService
	body       *map[string]interface{}
}

func (r QallAPILiveKitWebhookRequest) Body(body map[string]interface{}) QallAPILiveKitWebhookRequest {
	r.body = &body
	return r
}

func (r QallAPILiveKitWebhookRequest) Execute() (*http.Response, error) {
	return r.ApiService.LiveKitWebhookExecute(r)
}

/*
LiveKitWebhook LiveKit Webhook受信

LiveKit側で設定したWebhookから呼び出されるエンドポイントです。   参加者の入室・退出などのイベントを受け取り、サーバ内で処理を行います。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return QallAPILiveKitWebhookRequest
*/
func (a *QallAPIService) LiveKitWebhook(ctx context.Context) QallAPILiveKitWebhookRequest {
	return QallAPILiveKitWebhookRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *QallAPIService) LiveKitWebhookExecute(r QallAPILiveKitWebhookRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallAPIService.LiveKitWebhook")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/webhook"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/webhook+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type QallAPIPostSoundboardRequest struct {
	ctx        context.Context
	ApiService *QallAPIService
	audio      *os.File
	soundName  *string
	stampId    *string
}

// アップロードする音声ファイル(20秒以内)
func (r QallAPIPostSoundboardRequest) Audio(audio *os.File) QallAPIPostSoundboardRequest {
	r.audio = audio
	return r
}

// ユーザが自由につけるサウンド名
func (r QallAPIPostSoundboardRequest) SoundName(soundName string) QallAPIPostSoundboardRequest {
	r.soundName = &soundName
	return r
}

// アイコンスタンプID
func (r QallAPIPostSoundboardRequest) StampId(stampId string) QallAPIPostSoundboardRequest {
	r.stampId = &stampId
	return r
}

func (r QallAPIPostSoundboardRequest) Execute() (*SoundboardUploadResponse, *http.Response, error) {
	return r.ApiService.PostSoundboardExecute(r)
}

/*
PostSoundboard サウンドボード用の短い音声ファイルをアップロード

15秒程度の短い音声ファイルを multipart/form-data で送信し、S3(互換ストレージ)にアップロードします。   クライアントは「soundName」というフィールドを送信し、それをDBに保存して関連付けを行います。   また、サーバ側で soundId を自動生成し、S3のファイル名に使用します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return QallAPIPostSoundboardRequest
*/
func (a *QallAPIService) PostSoundboard(ctx context.Context) QallAPIPostSoundboardRequest {
	return QallAPIPostSoundboardRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SoundboardUploadResponse
func (a *QallAPIService) PostSoundboardExecute(r QallAPIPostSoundboardRequest) (*SoundboardUploadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SoundboardUploadResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallAPIService.PostSoundboard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/soundboard"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.audio == nil {
		return localVarReturnValue, nil, reportError("audio is required and must be specified")
	}
	if r.soundName == nil {
		return localVarReturnValue, nil, reportError("soundName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var audioLocalVarFormFileName string
	var audioLocalVarFileName string
	var audioLocalVarFileBytes []byte

	audioLocalVarFormFileName = "audio"
	audioLocalVarFile := r.audio

	if audioLocalVarFile != nil {
		fbs, _ := io.ReadAll(audioLocalVarFile)

		audioLocalVarFileBytes = fbs
		audioLocalVarFileName = audioLocalVarFile.Name()
		audioLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: audioLocalVarFileBytes, fileName: audioLocalVarFileName, formFileName: audioLocalVarFormFileName})
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "soundName", r.soundName, "", "")
	if r.stampId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stampId", r.stampId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QallAPIPostSoundboardPlayRequest struct {
	ctx                   context.Context
	ApiService            *QallAPIService
	soundboardPlayRequest *SoundboardPlayRequest
}

func (r QallAPIPostSoundboardPlayRequest) SoundboardPlayRequest(soundboardPlayRequest SoundboardPlayRequest) QallAPIPostSoundboardPlayRequest {
	r.soundboardPlayRequest = &soundboardPlayRequest
	return r
}

func (r QallAPIPostSoundboardPlayRequest) Execute() (*SoundboardPlayResponse, *http.Response, error) {
	return r.ApiService.PostSoundboardPlayExecute(r)
}

/*
PostSoundboardPlay アップロード済み音声を LiveKit ルームで再生

S3上にある音声ファイルの署名付きURLを生成し、   Ingressを介して指定ルームに音声を流します。     該当ルームに参加しているユーザであれば再生可能とします。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return QallAPIPostSoundboardPlayRequest
*/
func (a *QallAPIService) PostSoundboardPlay(ctx context.Context) QallAPIPostSoundboardPlayRequest {
	return QallAPIPostSoundboardPlayRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SoundboardPlayResponse
func (a *QallAPIService) PostSoundboardPlayExecute(r QallAPIPostSoundboardPlayRequest) (*SoundboardPlayResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SoundboardPlayResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallAPIService.PostSoundboardPlay")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/soundboard/play"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.soundboardPlayRequest == nil {
		return localVarReturnValue, nil, reportError("soundboardPlayRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.soundboardPlayRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QallAPIUpdateRoomMetadataRequest struct {
	ctx                 context.Context
	ApiService          *QallAPIService
	roomId              string
	qallMetadataRequest *QallMetadataRequest
}

// ルームのメタデータ
func (r QallAPIUpdateRoomMetadataRequest) QallMetadataRequest(qallMetadataRequest QallMetadataRequest) QallAPIUpdateRoomMetadataRequest {
	r.qallMetadataRequest = &qallMetadataRequest
	return r
}

func (r QallAPIUpdateRoomMetadataRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateRoomMetadataExecute(r)
}

/*
UpdateRoomMetadata ルームのメタデータを更新

ルームのメタデータを更新します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roomId ルームUUID
	@return QallAPIUpdateRoomMetadataRequest
*/
func (a *QallAPIService) UpdateRoomMetadata(ctx context.Context, roomId string) QallAPIUpdateRoomMetadataRequest {
	return QallAPIUpdateRoomMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		roomId:     roomId,
	}
}

// Execute executes the request
func (a *QallAPIService) UpdateRoomMetadataExecute(r QallAPIUpdateRoomMetadataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QallAPIService.UpdateRoomMetadata")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/qall/rooms/{roomId}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"roomId"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.qallMetadataRequest == nil {
		return nil, reportError("qallMetadataRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.qallMetadataRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
